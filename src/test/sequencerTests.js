'use strict';

var sequencer = require('../main/sequencer'),
  playbackSlotMock = require('./playbackSlotMock'),
  defaults = require('lodash-node/modern/objects/defaults'),
  defer = require('lodash-node/modern/functions/defer'),
  after = require('lodash-node/modern/functions/after'),
  times = require('lodash-node/modern/utilities/times'),
  identity = require('lodash-node/modern/utilities/identity');


describe('A sequencer', function() {

  /**
   * @param {function(Object)=} inter
   * @returns {Sequencer}
   */
  function sequencerWithDefaults(inter) {
    inter = inter || identity;

    var defaultConfig = {
      nextEntryProducer: function(entry) {
        return null;
      },
      playbackSlotProducer: function(config) {
        var slot = playbackSlotMock({
          entry: config.entry,
          video: {provider: 'mock', id: 'video-' + config.entry}
        });
        slot.load.and.returnValue(Promise.resolve());
        slot.end.and.returnValue(Promise.resolve());
        return slot;
      },
      comingNext: function(currentVideo, comingVideo) {

      }
    };
    return sequencer(defaults({}, inter(defaultConfig), defaultConfig));
  }

  var _entries;

  beforeEach(function() {
    _entries = times(5, function(idx) {
      var id = 'mockEntry' + idx;
      return {
        id: id,
        toString: function() {
          return id;
        }
      };
    })
  });

  it('calls nextEntryProducer with a "null" arguments on first call to play', function() {
    var nextEntryProducerSpy = jasmine.createSpy('nextEntryProducerSpy');
    var seq = sequencerWithDefaults(function() {
      return {
        nextEntryProducer: nextEntryProducerSpy
      }
    });

    seq.play();

    expect(nextEntryProducerSpy).toHaveBeenCalledWith(null);
  });

  it('executes the right sequence when manually skipping to an entry', function(done) {
    var nextEntryProducerSpy =
        jasmine.createSpy('nextEntryProducerSpy')
          .and.callFake(function(entry) {
            var idx = 0;
            if (entry) {
              idx = _entries.indexOf(entry) + 1;
            }
            if (idx >= _entries.length) {
              return null;
            }
            return _entries[idx];
          }),

      playbackSlotProducerSpy = jasmine.createSpy('nextEntryProducerSpy');

    var seq = sequencerWithDefaults(function(seqDefaultCfg) {
      return {
        nextEntryProducer: nextEntryProducerSpy,
        playbackSlotProducer: playbackSlotProducerSpy
          .and.callFake(function(producerCfg) {
            finishGate();
            return seqDefaultCfg.playbackSlotProducer(producerCfg);
          })
      }
    });

    var expectedSlotProducerCallsCount = 4,
      finishGate = after(expectedSlotProducerCallsCount, function() {

        expect(nextEntryProducerSpy.calls.allArgs()).toEqual([
          // generated by first play
          [null],
          // asked for the next entry after the entry 1
          [_entries[0]],
          // asked for the next entry after the entry 3
          [_entries[3]]
        ]);

        var slotLoadedEntries = playbackSlotProducerSpy.calls.allArgs()
          .map(function(args) {
            return args[0].entry;
          });

        expect(slotLoadedEntries).toEqual([
          // play from pristine state
          _entries[0],
          // preload next after entry 1 playing
          _entries[1],
          // manually skipped to entry 3
          _entries[3],
          // preload next after entry 3 playing
          _entries[4]
        ]);

        defer(done);
      });

    seq.play();

    defer(function() {
      seq.skip(_entries[3]);
    });
  });

});
